module XmlStructWriter

using LightXML
using TimeZones
using Printf
using Format
using AbstractXsdTypes

export write_xml

"""
	write_xml(xml_object, xml_path::AbstractString)::Nothing

Write the given `xml_object` to the path specified by `xml_path`.

The `xml_object` must be of a type generated by the XsdToStruct package.
It is also necessary that the dict in the `__xml_attributes` field of this object has the following two keys:
* A key `__root_name` that should contain the name of the root element of the xml file.
* An entry with the correct xmlns attribute that gives name of the namespace and the corresponding URI of the root element, see [the xml specification](https://www.w3.org/TR/xml-names/#ns-decl) for details.
Please consult the given examples if this is unclear; or inspect an XML loaded with XmlStructLoader, it will contain all the
needed entries in the `__xml_attributes` field.

With this input the written XML is valid according to the schema that was used to generate the struct definitions with
XsdToStruct.

# Examples
Creating an XML from scratch:
```julia-repl
julia> include(joinpath("Example", "Example.jl"))
julia> using .ExampleSchema

julia> using XmlStructWriter

julia> Example1 = ExampleComplexType(
	Element_double=100.22,
	Element_boolean=true,
	Element_integer=-778
)

julia> xml_attributes = Dict(
	"xmlns:xsi"=>"http://www.w3.org/2001/XMLSchema-instance",
	"xsi:schemaLocation"=>"ExampleSchema Example.xsd",
	"xmlns:ExampleSchema"=>"ExampleSchema",
	"__root_name"=>"document"
)

julia> document = documentType(
	Example1=Example1,
	Example2="AA99",
	__xml_attributes=xml_attributes
)

julia> write_xml(document, "example.xml")
```

Loading an XML, editing a field, and then writing to a new file, we are using Accessors.jl here which is recommended:
```julia-repl
julia> include(joinpath("Example", "Example.jl"))
julia> using .ExampleSchema

julia> using XmlStructLoader
julia> using XmlStructWriter
julia> using Accessors

julia> xml_original = load("example.xml", ExampleSchema)

julia> xml_new = @set xml_original.Example1.Element_double = -789.123
julia> write_xml(xml_new, "example_new.xml")
```
"""
function write_xml(xml_object, xml_path::AbstractString)::Nothing

    # make sure directory exists
    if !isdir(dirname(xml_path))
        mkpath(dirname(xml_path))
    end
    xdoc = XMLDocument()

    root_name = pop!(xml_object.__xml_attributes, "__root_name")
    name_space_string = first((
        key for
        key in keys(xml_object.__xml_attributes) if occursin("xmlns", key) && !occursin(r"xmlns:xsi|xmlns:xsd", key)
    ))
    name_space = last(split(name_space_string, ":"))
    root_element = create_xml_element(xml_object, "$name_space:$root_name")

    set_root(xdoc, root_element)
    save_file(xdoc, xml_path)
    xml_object.__xml_attributes["__root_name"] = root_name  # restore popped value

    return nothing
end

const excluded_names = [:__xml_attributes, :__validated]

function create_xml_element(xml_object::AbstractXsdTypes.AbstractXSDComplex, name::AbstractString)
    @debug "Creating XML element from complex struct $name"
    xml_element = new_element(name)
    xml_property_names = filter(name -> name âˆ‰ excluded_names, Base.invokelatest(propertynames, xml_object))
    for property in xml_property_names
        property_value = Base.invokelatest(getproperty, xml_object, property)
        add_child_element!(xml_element, property, property_value)
    end
    add_attributes!(xml_element, xml_object)
    return xml_element
end

function add_child_element!(xml_element, property, value::Any)::Nothing
    property_element = create_xml_element(value, string(property))
    add_child(xml_element, property_element)
    return nothing
end

function add_child_element!(xml_element, property, value::AbstractVector)::Nothing
    for sub_value in value
        add_child_element!(xml_element, property, sub_value)
    end
    return nothing
end

# nothing to do in this case
add_child_element!(_, _, _::Nothing)::Nothing = nothing

function create_xml_element(xml_object, name::AbstractString)
    @debug "Creating XML element from $xml_object"
    xml_element = new_element(name)
    set_content(xml_element, generate_xml_string(xml_object))
    add_attributes!(xml_element, xml_object)
    return xml_element
end

function add_attributes!(xml_element, xml_object)::Nothing
    if (
        hasfield(typeof(xml_object), :__xml_attributes) &&
        !isnothing(xml_object.__xml_attributes) &&
        !isempty(xml_object.__xml_attributes)
    )
        set_attributes(xml_element, xml_object.__xml_attributes)
    end
    return nothing
end

@inline function generate_xml_string(xml_object::AbstractXsdTypes.AbstractXSDSimpleTypes)::String
    @debug "Generating XML string from $xml_object"
    return string(xml_object.value)
end

function generate_xml_string(xml_object::AbstractXsdTypes.AbstractXSDFloat)::String
    @debug "Generating XML string from $xml_object"
    if AbstractXsdTypes.fraction_digits_check in AbstractXsdTypes.get_restriction_checks(typeof(xml_object))
        max_fraction_digits = AbstractXsdTypes.get_max_fraction_digits(typeof(xml_object))
        xml_object = cfmt("%.$(max_fraction_digits)f", xml_object)
    else
        xml_object = @sprintf("%f", xml_object)
    end
    return xml_object
end

@inline function generate_xml_string(xml_object::AbstractXsdTypes.AbstractXSDString)::String
    @debug "Generating XML string from $xml_object"
    return xml_object.value
end

@inline function generate_xml_string(s::String)::String
    @debug "Generating XML string from $s"
    return s
end

@inline function generate_xml_string(x)::String
    @debug "Generating XML string from $x"
    return string(x)
end

end # module XmlStructWriter
