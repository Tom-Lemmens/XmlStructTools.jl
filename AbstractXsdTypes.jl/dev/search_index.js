var documenterSearchIndex = {"docs":
[{"location":"#AbstractXsdTypes","page":"Home","title":"AbstractXsdTypes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package contains abstract types and generic functions used by the output of the XsdToStruct package.","category":"page"},{"location":"#Restrictions","page":"Home","title":"Restrictions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The types defined in XSD documents often have restrictions on what data they can contain. The implementations of these restriction checks are contained in this package. Note that not all possible restrictions are implemented yet.","category":"page"},{"location":"#Defaults","page":"Home","title":"Defaults","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package also provides a defaults function for handling specified default values of XSD types. The generic implementation will return an empty NamedTuple. But, if there are defaults specified in the XSD file for a particular type the output of XsdToStruct will contain a defaults function that returns a NamedTuple which maps the field name to its default value.","category":"page"},{"location":"#Naive-conversion","page":"Home","title":"Naive conversion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are also some naive conversion functions included with this package. These give a \"best effort\" generic conversion of one type generated by XsdToStruct into another one. For example, a common use case is when an two XSD files describe compatible data types for certain particular elements but are otherwise completely different. You might have a function available written for the data type of the first schema but want to use it on data loaded from an XML file that follows the second schema. You will not be able to parse the complete XML file using the types of the first schema and a function call on the data loaded using the second schema will not dispatch to the correct function. With the naive convert function included in this package you can load the data of the XML and then try to convert the compatible subfield into the type from the first schema, which will then dispatch correctly.","category":"page"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Modules = [AbstractXsdTypes]","category":"page"},{"location":"docstrings/#AbstractXsdTypes.AbstractXSDComplex","page":"Docstrings","title":"AbstractXsdTypes.AbstractXSDComplex","text":"AbstractXSDComplex\n\nAbstract type used for complex XSD structs.\n\nThe contract for concrete subtypes is:\n\neach fieldname is an XML element\nexcept __xml_attributes, which contains the attributes\nexcept __validated, which indicates if the object was validated at construction with respect to the XSD schema\n\nThis type has a special Base.show which calls AbstractXsdTypes.print_tree\n\nimport AbstractXsdTypes: AbstractXSDComplex\n\nstruct SimpleType <: AbstractXSDComplex\n    Element1::String\n    Element2::Float64\n    __xml_attributes::Union{Nothing,Dict{String,String}}\n    __validated::Bool\nend\n\nsimple = SimpleType(\"value\", 1e-3, Dict(\"x\" => \"y\"), true)\nshow(simple)\n\n# output\n\n|-- Element1: value\n|-- Element2: 0.001\n|-- __xml_attributes: Dict(\"x\" => \"y\")\n|-- __validated: true\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#AbstractXsdTypes.AbstractXSDFloat","page":"Docstrings","title":"AbstractXsdTypes.AbstractXSDFloat","text":"AbstractXSDFloat <: AbstractFloat\n\nMust have a value field, an __xml_attributes field, and a __validated field.\n\nimport AbstractXsdTypes: AbstractXSDFloat\n\nstruct FloatType <: AbstractXSDFloat\n    value::Float64\n    __xml_attributes::Union{Nothing,Dict{String,String}}\n    __validated::Bool\nend\n\nxsd_float = FloatType(1.0, Dict(\"x\" => \"y\"), true)\nshow(xsd_float)\n\n# output\n\n1.0\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#AbstractXsdTypes.AbstractXSDSigned","page":"Docstrings","title":"AbstractXsdTypes.AbstractXSDSigned","text":"AbstractXSDSigned <: Signed\n\nMust have a value field, an __xml_attributes field, and a __validated field.\n\nimport AbstractXsdTypes: AbstractXSDSigned\n\nstruct SignedType <: AbstractXSDSigned\n    value::Int64\n    __xml_attributes::Union{Nothing,Dict{String,String}}\n    __validated::Bool\nend\n\nxsd_signed = SignedType(1, Dict(\"x\" => \"y\"), true)\nshow(xsd_signed)\n\n# output\n\n1\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#AbstractXsdTypes.AbstractXSDString","page":"Docstrings","title":"AbstractXsdTypes.AbstractXSDString","text":"AbstractXSDString <: AbstractString\n\nMust have a value field, an __xml_attributes field, and a __validated field.\n\nimport AbstractXsdTypes: AbstractXSDString\n\nstruct StringType <: AbstractXSDString\n    value::String\n    __xml_attributes::Union{Nothing,Dict{String,String}}\n    __validated::Bool\nend\n\nxsd_string = StringType(\"value\", Dict(\"x\" => \"y\"), true)\nshow(xsd_string)\n\n# output\n\n\"value\"\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#AbstractXsdTypes.AbstractXSDUnion","page":"Docstrings","title":"AbstractXsdTypes.AbstractXSDUnion","text":"AbstractXsdTypes.AbstractXSDUnion\n\nAbstract type used for XSD Union types.\n\nFirst field must be the value, which will be another XSD type.\n\nYou must use the AbstractXsdTypes.union_value function in the constructor as shown below. This is to make sure the values get converted to a union value.\n\nYou must implement the AbstractXsdTypes.union_types function.\n\nxml attributes will be passed along to the value type.\n\nBase.@kwdef @concrete struct UnionType <: AbstractXsdTypes.AbstractXSDUnion\n    value <: Union{FloatType,AnotherFloatType,StringType}\n    __validated::Bool = true\nend\n\nAbstractXsdTypes.union_types(::Type{<:UnionType}) = (FloatType, AnotherFloatType, StringType)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#AbstractXsdTypes.AbstractXSDUnsigned","page":"Docstrings","title":"AbstractXsdTypes.AbstractXSDUnsigned","text":"AbstractXSDUnsigned <: Unsigned\n\nMust have a value field, an __xml_attributes field, and a __validated field.\n\nimport AbstractXsdTypes: AbstractXSDUnsigned\n\nstruct UnsignedType <: AbstractXSDUnsigned\n    value::UInt64\n    __xml_attributes::Union{Nothing,Dict{String,String}}\n    __validated::Bool\nend\n\nxsd_unsigned = UnsignedType(0x0000000000000001, Dict(\"x\" => \"y\"), true)\nshow(xsd_unsigned)\n\n# output\n\n0x0000000000000001\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#AbstractXsdTypes.XSDRestrictionViolationError","page":"Docstrings","title":"AbstractXsdTypes.XSDRestrictionViolationError","text":"XSDRestrictionViolationError <: Exception\n\nCustom exception type to indicate that something was passed to an XSD type constructor which violates a restriction for that type.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#AbstractXsdTypes.XSDStringRestrictionViolationError","page":"Docstrings","title":"AbstractXsdTypes.XSDStringRestrictionViolationError","text":"XSDStringRestrictionViolationError <: XSDRestrictionViolationError\n\nCustom exception type to indicate that a string was passed to an XSD type constructor which violates a string based restriction for that type.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#AbstractXsdTypes.XSDValueRestrictionViolationError","page":"Docstrings","title":"AbstractXsdTypes.XSDValueRestrictionViolationError","text":"XSDValueRestrictionViolationError <: XSDRestrictionViolationError\n\nCustom exception type to indicate that a value was passed to an XSD type constructor which violates a value based restriction for that type.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#AbstractXsdTypes.can_be_converted-Union{Tuple{S}, Tuple{T}, Tuple{Type{T}, Type{S}}} where {T<:AbstractXsdTypes.AbstractXSDComplex, S<:AbstractXsdTypes.AbstractXSDComplex}","page":"Docstrings","title":"AbstractXsdTypes.can_be_converted","text":"can_be_converted(::Type{T}, ::Type{S})::Bool where {T<:AbstractXSDComplex, S<:AbstractXSDComplex}\n\nNaive check to see if type S can be converted to type T. This function will only look for compatible field names, compatibility of field types is not checked.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#AbstractXsdTypes.defaults","page":"Docstrings","title":"AbstractXsdTypes.defaults","text":"AbstractXsdTypes.defaults(::Type{MyType}) = (:field_a=default_value, :field_b=>default_value)\n\nDefine default arguments for various fields of MyType, which will be generated by XsdToStruct and can be used by your custom XML parser.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#AbstractXsdTypes.print_tree-Tuple{IO, AbstractXsdTypes.AbstractXSDComplex}","page":"Docstrings","title":"AbstractXsdTypes.print_tree","text":"print_treeprint_tree(\n    io::IO,\n    x::AbstractXSDComplex;\n    print_all::Bool=false,\n    indent_string::AbstractString=\"\"\n)::Nothing\n\nPrints the AbstractXSDComplex as a tree.\n\n\n\n\n\n","category":"method"}]
}
